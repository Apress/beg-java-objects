// Class #1:  ListeningObject.java

// Copyright 2005 by Jacquie Barker - all rights reserved.

// This is one half of the "listening equation":  namely, and object that
// is registered to listen other objects capable of generating 
// property change events (PropertyChangeEvents).  Think of this as a giant
// "ear" or antenna!
//
// This can be ANY type of object:  commonly, it will be a GUI component
// ("view" object) that is listening for changes in some domain ("model") 
// object.

import java.beans.*;

// We implement the PropertyChangeListener interface so that instances
// of THIS class will know whenever a significant property has changed 
// in instances of some OTHER class:  namely, the objects being
// "listened to". 

public class ListeningObject implements PropertyChangeListener {
	// Optional:  I am going to hold on to the object to
	// be listened to, just for the heck of it.  I don't actually
	// USE this object anywhere ... just want to demonstrate this.
	Object objectToBeListenedTo;

	// Somehow, the "listening" object A has to obtain a "handle"
	// on the "listened to" object B.  This is but ONE way to do so:
	// namely, to hand B to A via a method argument.  (Another way:
	// "B" can be declared as a public (static) attribute of the
	// application, such that it is effectively global.)

	// (Note that the data type of this next method's argument,
	// "ListenedToObject", is an interface that I evented;
	// see comments in ListenedToObject.java for details.
	public void handInListenedToObject(ListenedToObject 
					   objectToBeListenedTo) {
		// Register THIS object to be a listener for PropertyChange 
		// events generated by THAT object.  (See comments in
		// ListenedToObject.java and SomeObject.java, respectively.)
		objectToBeListenedTo.addPropertyChangeListener(this);

		// Optional:  I am going to hold on to the object to
		// be listened to, just for the heck of it.
		this.objectToBeListenedTo = objectToBeListenedTo;
	}

	// The PropertyChangeListener interface mandates that the
	// following method be implemented, to handle events
	// when they are received.  No matter how many different objects,
	// of varying types, that this object is listening to, they will 
	// ALL funnel through this one method.  Check out the documentation 
	// for a PropertyChangeEvent to see what all we can "discern" about it.
	public void propertyChange(PropertyChangeEvent e) {
		// Check the property name to see what type of property it is.
	        if (e.getPropertyName().equals("foobar")) {
			// Within this method, we can use e.getOldValue() or
			// e.getNewValue(), which return Objects, or
			// e.getPropertyName(), which returns a String,
			// among other methods.
			System.out.println("For property foobar, " +
				"the old value was " + e.getOldValue() +
				" and the new value was " + e.getNewValue() +
				" ...");

				// Do whatever "real" processing is necessary,
				// such as updating the GUI; synchronizing
				// data; whatever.
		}
	        else if (e.getPropertyName().equals("barfoo")) {
			System.out.println("For property barfoo, " +
				"the old value was " + e.getOldValue() +
				" and the new value was " + e.getNewValue() +
				" ...");

				// Do whatever "real" processing is necessary.
		}
	}
}
